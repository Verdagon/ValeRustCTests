// Seamless C->Rust example: launching a subprocess

// Import types. More advanced compilers with generics wouldn't need
// to specify these generic args in theory, it would basically be a
// vanilla java import.
#pragma rsuse OsString = std::ffi::OsString
#pragma rsuse VecOsStringRef = std::vec::Vec<&OsString>
#pragma rsuse PopenConfig = subprocess::PopenConfig
#pragma rsuse Popen = subprocess::Popen
#pragma rsuse PopenResult = subprocess::Result<Popen>
#pragma rsuse ExitStatusResult = subprocess::Result<subprocess::ExitStatus>
// Import methods. AFAICT, more advanced compilers with generics won't
// need any of these imports in theory.
#pragma rsuse OsString_new = OsString::new
#pragma rsuse OsString_pushRefStr = OsString::push::<&str>
#pragma rsuse OsString_drop = OsString::drop
#pragma rsuse VecOsStringRef_new = VecOsStringRef::new
#pragma rsuse VecOsStringRef_push = VecOsStringRef::push
#pragma rsuse VecOsStringRef_as_slice = VecOsStringRef::as_slice
#pragma rsuse VecOsStringRef_drop = VecOsStringRef::Drop::drop
#pragma rsuse PopenConfig_default = PopenConfig::default
#pragma rsuse Popen_create = Popen::create::<&OsString>
#pragma rsuse Popen_wait = Popen::wait
#pragma rsuse Popen_drop = Popen::Drop::drop
#pragma rsuse PopenResult_is_ok = PopenResult::is_ok
#pragma rsuse PopenResult_unwrap = PopenResult::unwrap
#pragma rsuse PopenResult_drop = PopenResult::drop
#pragma rsuse ExitStatusResult_is_ok = ExitStatusResult::is_ok
#pragma rsuse ExitStatusResult_drop = ExitStatusResult::drop
// Import the header generated by the Makefile invoking the tool
#include <rust_deps/rust_deps.h>

#include <stdio.h>

int main() {
  // let program_name_osstring = OsString::new();
  OsString program_name_osstring = OsString_new();
  // program_name_osstring.push("/bin/cat");
  OsString_pushRefStr(&program_name_osstring, VR_StrFromCStr("/bin/cat"));
  
  // let arg1_osstring = OsString::new();
  OsString arg1_osstring = OsString_new();
  // arg1_osstring.push("/Users/verdagon/hello.txt");
  OsString_pushRefStr(&arg1_osstring, VR_StrFromCStr("/Users/verdagon/hello.txt"));
  
  // let argv = Vec::new();
  VecOsStringRef argv = VecOsStringRef_new();
  // argv.push(program_name_osstring);
  VecOsStringRef_push(&argv, &program_name_osstring);
  // argv.push(program_name_osstring);
  VecOsStringRef_push(&argv, &arg1_osstring);

  // let result = Popen::create(argv, PopenConfig::default());
  PopenResult create_result =
      Popen_create(
          VecOsStringRef_as_slice(&argv), PopenConfig_default());
  
  OsString_drop(&program_name_osstring);
  OsString_drop(&arg1_osstring);
  VecOsStringRef_drop(&argv);

  // match create_result {
  //   Err(_) => panic!("Failed to open subprocess!"),
  if (!PopenResult_is_ok(&create_result)) {
    printf("Failed to open subprocess!\n");
    PopenResult_drop(&create_result);
    return 1;
  }
  //   Ok(process) => {
  Popen process = PopenResult_unwrap(create_result);
  //     let wait_result = process.wait();
  ExitStatusResult wait_result = Popen_wait(&process);
  //     if !wait_result.is_ok() {
  if (!ExitStatusResult_is_ok(&wait_result)) {
    //     panic!("Failed to wait on subprocess!");
    printf("Failed to wait on subprocess!\n");
    ExitStatusResult_drop(&wait_result);
    Popen_drop(&process);
    PopenResult_drop(&create_result);
    return 1;
  }

  printf("Success!\n");
  ExitStatusResult_drop(&wait_result);
  Popen_drop(&process);
  PopenResult_drop(&create_result);
  return 0;
}
